<!DOCTYPE html>
<html>
	<head>
		<title>Hybrid editor</title>
		<meta charset="UTF-8">
		<meta name="google" value="notranslate">
		
		<script src="https://unpkg.com/blockly/blockly.min.js"></script>
		<script src="https://unpkg.com/blockly/msg/en.js"></script>
		
		<link
			rel="stylesheet"
			data-name="vs/editor/editor.main"
			href="https://unpkg.com/monaco-editor/min/vs/editor/editor.main.css" 
		/>
		
		<style>
			body {background-color: #fdfdfd; color: #333; font-family: Helvetica, Arial}
		</style>
	</head>
	
	<body>
		<h1>Hybrid Editor</h1>
		<p>Below there are 2 editing environments for a <b>State Machine</b>: a Block Based Environment (BBE) and a Text Based Environment (TBE). Any change in the BBE will automatically  update the TBE, but changes in the TBE will only be visible in the BBE if
			the TBE is selected and the 'End' button is pressed. Only syntactically correct updates are executed.
		</p>
		<p>
			<a href="#" onclick="loadDocTest();">Test</a><br />
			<a href="#" onclick="loadDocParse();">Parse</a>
		</p>
		<div style="width: 100%">
			<div id="blockDiv" style="height: 600px; width: 720px; position: absolute; left: 8px;"></div>
			<div id="container2" style="height: 600px; width: 720px; position: absolute; left: 736px; border: 1px solid grey;"></div>
		</div>
		
		<script>var require = { paths: { vs: 'https://unpkg.com/monaco-editor/min/vs' } };</script>
		  <script src="https://unpkg.com/monaco-editor/min/vs/loader.js"></script>
		<script src="https://unpkg.com/monaco-editor/min/vs/editor/editor.main.nls.js"></script>
		  <script src="https://unpkg.com/monaco-editor/min/vs/editor/editor.main.js"></script>
		<script>
		  var editor = monaco.editor.create(document.getElementById('container2'), {
			value: "",
			language: 'javascript'
		  });
		</script>
	</body>
	
	<script type="text/javascript">
		Blockly.Blocks['Machine/machine'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "Machine/machine",
					  "message0" : "machine %1 %2 %3",
					  "args0" : [
						{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "id",
						  "type" : "field_input",
						  "text" : ""
						},
							{
						  "name" : "states",
						  "type" : "input_statement",
						  "check" : ["State", "epsilon"]
						},
						
					],
					  "colour" : 120,
					  
					  
					  
					  "inputsInline" : false,
					  "tooltip" : "",
					  "helpUrl" : ""
					}
				);
			}
		}
		Blockly.Blocks['Id/id'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "Id/id",
					  "message0" : "%1",
					  "args0" : [
						{
						  "name" : "Id",
						  "type" : "field_input",
						  "text" : "variable"
						},
						
					],
					  "colour" : 52,
					  "output" : "Id",
					  
					  
					  "inputsInline" : true,
					  "tooltip" : "",
					  "helpUrl" : ""
					}
				);
			}
		}
		Blockly.Blocks['State/state'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "State/state",
					  "message0" : "state %1 %2 { %3 %4 } %5",
					  "args0" : [
						{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "id",
						  "type" : "field_input",
						  "text" : ""
						},
							{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "transitions",
						  "type" : "input_statement",
						  "check" : ["Trans", "epsilon"]
						},
							{
						  "name" : "",
						  "type" : "input_dummy"
						},
						
					],
					  "colour" : 54,
					  
					  "previousStatement" : "State",
					  "nextStatement" : "State",
					  "inputsInline" : true,
					  "tooltip" : "state",
					  "helpUrl" : ""
					}
				);
			}
		}
		Blockly.Blocks['Trans/transition'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "Trans/transition",
					  "message0" : "on %1 %2 to %3 %4 ",
					  "args0" : [
						{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "on",
						  "type" : "field_input",
						  "text" : ""
						},
							{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "to",
						  "type" : "field_input",
						  "text" : ""
						},
						
					],
					  "colour" : 322,
					  
					  "previousStatement" : "Trans",
					  "nextStatement" : "Trans",
					  "inputsInline" : true,
					  "tooltip" : "transition",
					  "helpUrl" : ""
					}
				);
			}
		}

		var toolbox = {
					"kind": "categoryToolbox",
					"contents": [
						{
							"kind": "category",
							"name": "Id",
							"contents": [
								{
									"kind": "block",
									"type": "Id/id"
								}
							]
						}, {
							"kind": "category",
							"name": "Machine",
							"contents": [
								{
									"kind": "block",
									"type": "Machine/machine"
								}
							]
						}, {
							"kind": "category",
							"name": "State",
							"contents": [
								{
									"kind": "block",
									"type": "State/state"
								}
							]
						}, {
							"kind": "category",
							"name": "Trans",
							"contents": [
								{
									"kind": "block",
									"type": "Trans/transition"
								}
							]
						}
					]
				};

		Blockly.BlockSvg.START_HAT = true;
		var workspace = Blockly.inject('blockDiv', {
			toolbox: toolbox,
			collapse: true,
		   toolboxPosition: 'start', // end
		   trashcan: true
		});

		const langGen = new Blockly.Generator('LangGen');
			
		workspace.addChangeListener(Blockly.Events.disableOrphans);

		langGen['Machine/machine'] = function(block) {
			function getBlockValues(a) {
					const returnBlock = a.getDescendants(true);
						if (returnBlock.length > 0) {
							var counter = 0;
							var returnString = '';
							
							if (typeof returnBlock[counter] !== 'undefined') {
								returnString += returnBlock[counter] + '\n';
							}
							
							return returnString;
						} else {
							return '';
						}
				}

				result = getBlockValues(block)
					
				return result;
		}

		langGen['Id/id'] = function (block) {
			return '';
		}

		langGen['State/state'] = function (block) {
			return '';
		}

		langGen['Trans/transition'] = function (block) {
			return '';
		}

		function myUpdateFunction(event) {
			var code = langGen.workspaceToCode(workspace);
			editor.setValue(code);
			
		}
			
		workspace.addChangeListener(myUpdateFunction);

		function getLast(block) {
			if (block.next.block != null) {
				return getLast(block.next.block);
			} else {
				return block;
			}
		}

		var updateBlockView = editor.addCommand(monaco.KeyCode.End, function () {
			var lastMachineBlock;
			var machineBlockCounter = 0;
			var lastStateBlock;
			var lastStateBlockCounter = 0;
			var workspaceObj = {};
			workspaceObj.blocks = {};
			workspaceObj.blocks.languageVersion = 0;
			workspaceObj.blocks.blocks = [];
			var editorInput = editor.getValue().split(" ");
			
			for (let i = 0; i < editorInput.length; i++) {
				if (editorInput[i] == "machine" || editorInput[i].endsWith("\nmachine")) {
					workspaceObj.blocks.blocks.push({
						"type": "Machine/machine", 
						"id": i+1,
						"x": machineBlockCounter * 100,
						"y": machineBlockCounter * 50,
						"fields": {
							"id": editorInput[i+1]
						},
						"inputs": {}
					});
					
					lastMachineBlock = workspaceObj.blocks.blocks[machineBlockCounter];
					machineBlockCounter += 1;
					i += 1;
				}
				
				if (editorInput[i] == "state") {
					if (editorInput[i+2] == "{") {
						var block = {
							"type": "State/state",
							"id": i,
							"fields": {
								"id": editorInput[i+1]
							},
							"inputs": {},
							"next": {}
						}
						
						if (lastMachineBlock.inputs.states == null) {
							lastMachineBlock.inputs.states = {};
							lastMachineBlock.inputs.states.block = block;
							lastStateBlock = lastMachineBlock.inputs.states.block;
						} else {
							var latestBlock = getLast(lastMachineBlock.inputs.states.block);
							latestBlock.next.block = block;
							lastStateBlock = latestBlock.next.block;
						}
						
						i += 2;
					}
				}
				
				if (editorInput[i] == "on") {
					var block = {
						"type": "Trans/transition",
						"id": i,
						"fields": {
							"on": editorInput[i+1],
							"to": editorInput[i+3]
						},
						"inputs": {},
						"next": {}
					}
					
					if (lastStateBlock.inputs.transitions == null) {
						lastStateBlock.inputs.transitions = {};
						lastStateBlock.inputs.transitions.block = block;
					} else {
						var latestBlock = getLast(lastStateBlock.inputs.transitions.block);
						latestBlock.next.block = block;
					}
					
					i += 3;
				}
			}
			
			var workspaceObjJSON = JSON.stringify(workspaceObj);
			workspace.clear();
			Blockly.serialization.workspaces.load(workspaceObj, workspace);
			var json = Blockly.serialization.workspaces.save(workspace);
			console.log(json);
		});

		function loadDocTest() {
			fetch('/test').then(x => x.text()).then(y => console.log(y));
		}
		
		function loadDocParse() {
			fetch('/parse?' + new URLSearchParams({code: editor.getValue()})).then(x => x.text()).then(y => console.log(y));
		}
	
	</script>
</html>