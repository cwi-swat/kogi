<!DOCTYPE html>
<html>
	<head>
		<title>Hybrid editor</title>
		<meta charset="UTF-8">
		<meta name="google" value="notranslate">
		
		<script src="https://unpkg.com/blockly@9.2.1/blockly.min.js"></script>
		<script src="https://unpkg.com/blockly@9.2.1/msg/en.js"></script>
		
		<link
			rel="stylesheet"
			data-name="vs/editor/editor.main"
			href="https://unpkg.com/monaco-editor/min/vs/editor/editor.main.css" 
		/>
		
		<style>
			body {background-color: #fdfdfd; color: #333; font-family: Helvetica, Arial}
			.bar {padding: 10px; margin: 10px; color: #333; background: #fafafa; border: 1px solid #ccc;} 
			.error {color: #ba3939; background: #ffe0e0; border: 1px solid #a33a3a; opacity: 0; transition: opacity 0.5s ease;}
		</style>
	</head>
	
	<body>
		<h1>Hybrid Editor</h1>
		<p>Below there are 2 editors for a <b>State Machine</b>: a Block-Based Editor (BBE) and a Text-Based Editor (TBE). <br/>
			When a change is found in either editor, it will first wait 1.0 second before automatically pushing the change to the other editor.
			<ul>
				<li>As the BBE is syntactically correct by design, the changes are directly pushed to the TBE.</li>
				<li>However, when changes occur in the TBE, it will first the the code to the Rascal webserver running this page so that the code can be parsed.
					<ul>
						<li>If the code is correct, the webserver will return JSON that is used to update the BBE.</li>
						<li>If the code is incorrect, it will send an error message with the location of the first character that is breaking the code.</li>
					</ul>
				</li>
			</ul> 
		</p>
		<div id="error_bar" class="bar error"></div>
		<div style="width: 100%">
			<div id="blockDiv" style="height: 600px; width: 720px; position: absolute; left: 8px;"></div>
			<div id="container2" style="height: 600px; width: 720px; position: absolute; left: 736px; border: 1px solid grey;"></div>
		</div>
		
		<script>var require = { paths: { vs: 'https://unpkg.com/monaco-editor/min/vs' } };</script>
		<script src="https://unpkg.com/monaco-editor/min/vs/loader.js"></script>
		<script src="https://unpkg.com/monaco-editor/min/vs/editor/editor.main.nls.js"></script>
		<script src="https://unpkg.com/monaco-editor/min/vs/editor/editor.main.js"></script>
		<script>
		  var editor = monaco.editor.create(document.getElementById('container2'), {
			value: "",
			language: 'javascript'
		  });
		</script>
	</body>
	
	<script type="text/javascript">

	/* Create all blocks that can be used */
		Blockly.Blocks['Machine/machine'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "Machine/machine",
					  "message0" : "machine %1 %2 %3",
					  "args0" : [
						{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "id",
						  "type" : "field_input",
						  "text" : ""
						},
							{
						  "name" : "states",
						  "type" : "input_statement",
						  "check" : ["State", "epsilon"]
						},
						
					],
					  "colour" : 120,
					  
					  
					  
					  "inputsInline" : false,
					  "tooltip" : "",
					  "helpUrl" : ""
					}
				);
			}
		}
		Blockly.Blocks['Id/id'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "Id/id",
					  "message0" : "%1",
					  "args0" : [
						{
						  "name" : "Id",
						  "type" : "field_input",
						  "text" : "variable"
						},
						
					],
					  "colour" : 52,
					  "output" : "Id",
					  
					  
					  "inputsInline" : true,
					  "tooltip" : "",
					  "helpUrl" : ""
					}
				);
			}
		}
		Blockly.Blocks['State/state'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "State/state",
					  "message0" : "state %1 %2 { %3 %4 } %5",
					  "args0" : [
						{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "id",
						  "type" : "field_input",
						  "text" : ""
						},
							{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "transitions",
						  "type" : "input_statement",
						  "check" : ["Trans", "epsilon"]
						},
							{
						  "name" : "",
						  "type" : "input_dummy"
						},
						
					],
					  "colour" : 54,
					  
					  "previousStatement" : "State",
					  "nextStatement" : "State",
					  "inputsInline" : true,
					  "tooltip" : "state",
					  "helpUrl" : ""
					}
				);
			}
		}
		Blockly.Blocks['Trans/transition'] = {
			init: function() {
				this.jsonInit(
					{
					  "type" : "Trans/transition",
					  "message0" : "on %1 %2 to %3 %4 ",
					  "args0" : [
						{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "on",
						  "type" : "field_input",
						  "text" : ""
						},
							{
						  "name" : "",
						  "type" : "input_dummy"
						},
							{
						  "name" : "to",
						  "type" : "field_input",
						  "text" : ""
						},
						
					],
					  "colour" : 322,
					  
					  "previousStatement" : "Trans",
					  "nextStatement" : "Trans",
					  "inputsInline" : true,
					  "tooltip" : "transition",
					  "helpUrl" : ""
					}
				);
			}
		}

		/* Create the toolbox used in the BBE */

		var toolbox = {
					"kind": "categoryToolbox",
					"contents": [
						{
							"kind": "category",
							"name": "Id",
							"contents": [
								{
									"kind": "block",
									"type": "Id/id"
								}
							]
						}, {
							"kind": "category",
							"name": "Machine",
							"contents": [
								{
									"kind": "block",
									"type": "Machine/machine"
								}
							]
						}, {
							"kind": "category",
							"name": "State",
							"contents": [
								{
									"kind": "block",
									"type": "State/state"
								}
							]
						}, {
							"kind": "category",
							"name": "Trans",
							"contents": [
								{
									"kind": "block",
									"type": "Trans/transition"
								}
							]
						}
					]
				};

		Blockly.BlockSvg.START_HAT = true;
		var workspace = Blockly.inject('blockDiv', {
			toolbox: toolbox,
			collapse: true,
		   toolboxPosition: 'start', // end
		   trashcan: true
		});

		/* Create simple block-to-text conversion */

		const langGen = new Blockly.Generator('LangGen');
			
		workspace.addChangeListener(Blockly.Events.disableOrphans);

		langGen['Machine/machine'] = function(block) {
			function getBlockValues(a) {
				const returnBlock = a.getDescendants(true);

				if (returnBlock.length > 0) {
					var counter = 0;
					var returnString = '';
					
					if (typeof returnBlock[counter] !== 'undefined') {
						returnString += returnBlock[counter] + '';
					}
					
					return returnString;
				} else {
					return '';
				}
			}

			result = getBlockValues(block);
					
			return result;
		}

		langGen['Id/id'] = function (block) {
			return '';
		}

		langGen['State/state'] = function (block) {
			return '';
		}

		langGen['Trans/transition'] = function (block) {
			return '';
		}

		/* The debounce function is used to prevent the update function calls to happen at every possible event 
		 * (for example, for every pixel a block has been moved, or for every character that has been typed).
		 * The function implementation as written below is from StackOverflow user Malk (https://stackoverflow.com/a/24004942) */

		function debounce(func, wait, immediate) {
			var timeout;

			return function() {
				var context = this, args = arguments;
				var callNow = immediate && !timeout;
				clearTimeout(timeout);

				timeout = setTimeout(function() {
					timeout = null;

					if(!immediate) {
						func.apply(context, args);
					}
				}, wait);

				if(callNow) func.apply(context, args);
			}
		}

		var isUpdating = false;

		/* Code below is for updating the TBE when there's a change in the BBE */

		function codeUpdate() {
			if (isUpdating) {
				isUpdating = false;
			} else {
				isUpdating = true;
				var code = langGen.workspaceToCode(workspace);
				editor.setValue(code);
			}
		}

		var debouncedCodeUpdate = debounce(codeUpdate, 1000);
			
		workspace.addChangeListener(debouncedCodeUpdate);
		
		/* Code below is for updating the BBE when there's a change in the TBE */
		function loadDocParse() {
			if (isUpdating) {
				isUpdating = false;
			} else {
				isUpdating = true;
				fetch('/parse?' + new URLSearchParams({code: editor.getValue()})).then(
					x => x.text()
				).then( y => {
					if (y.charAt(0) === "E" ) {
						error_bar = document.getElementById('error_bar');
						error_bar.innerHTML = y;
						error_bar.style.opacity = 1;
						isUpdating = false;
					} else {
						var response1 = JSON.parse(y);
						console.log(response1);
						error_bar.style.opacity = 0;
						error_bar.value = "";
						

						Blockly.serialization.workspaces.load(response1, workspace);
					}
				});
			}
		}

		var debouncedBlockUpdate = debounce(loadDocParse, 1000);

		editor.getModel().onDidChangeContent(debouncedBlockUpdate);
	
	</script>
</html>